<!DOCTYPE html>
<html lang="en" xmlns:sec="http://www.w3.org/1999/xhtml" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="projectId" th:content="${projectId}">
    <meta name="_csrf" th:content="${_csrf.token}" />
    <meta name="_csrf_header" th:content="${_csrf.headerName}" />
    <meta name="fileStructure" th:content="${fileStructure}">
    <meta name="projectLanguage" th:content="${language}">
    <link rel="icon" href="/favicon.png" type="image/png">
    <title th:text="'Проект: ' + ${projectName}">Project Title</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>


  * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
<!--            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;-->
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
        }

        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #f6f8fa;
            color: #24292e;
        }
        #container {
            display: flex;
            height: 100%;
            background-color: #282c34;
        }

        #sidebar {
            width: 300px;
             background: #ffffff;
             color: #24292e;
            overflow: hidden;
            transition: width 0.3s ease;
            border-right: 1px solid #d1d5da;

        }

        #jstree {
            overflow: auto;
<!--            height: calc(100% - 60px);-->
            padding: 20px;
            border-right: 1px solid #333;
        }

        #editor-container {
            position: relative;
            height: 100%;
            flex-grow: 1;
             width: calc(100% - 300px);
            transition: width 0.3s ease;
        }

        #editor {
            width: 100%;
            height: 100%;
        }

        .icon-panel {
            width: 60px;
            background-color: #f6f8fa;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #d1d5da;
            align-items: center;
            padding-top: 15px;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .icon-panel button {
            background: none;
            border: none;
            color: #24292e;
            margin: 10px 0;
            cursor: pointer;
            font-size: 24px;
            transition: transform 0.2s, color 0.3s;
        }

        .icon-panel button:hover {
            transform: scale(1.1);
            color: #28a745;

        }

        .btn-primary-custom {
            color: #fff;
            background-color: #007bff;
            border-color: #007bff;
            transition: background-color 0.3s, transform 0.2s;
        }

        .btn-primary-custom:hover {
            background-color: #0056b3;
            transform: scale(1.05);
        }

        #compile-output {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #f6f8fa;
            padding: 15px;
            color: #333;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #d1d5da;
        }

        #compile-output h3 {
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .code-explorer-heading {
            text-align: center;
            background: #333;
            padding: 10px;
            font-weight: bold;
            font-size: 1.1em;
            border-bottom: 1px solid #444;
        }
        #main-class-container {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border-radius: 5px;
            color: #24292e;
            border: 1px solid #d1d5da;
            display: flex;
            align-items: center;
            z-index: 1000;
            background-color: #f6f8fa;

        }

        #main-class-container label {
            margin-right: 5px;
        }

        #main-class-input {
            border: 1px solid #555;
            color: #24292e;
            padding: 2px 5px;
            border-radius: 3px;
        }
        #selectMainClassModal {
            display: none; /* Скрыто по умолчанию */
            position: fixed; /* Оставаться на месте */
            z-index: 1001; /* На вершине */
            left: 0;
            top: 0;
            width: 100%; /* Полная ширина */
            height: 100%; /* Полная высота */
            overflow: auto; /* Включить прокрутку, если необходимо */
            background-color: rgba(0,0,0,0.5); /* Черный с прозрачностью */
        }

        #selectMainClassModalContent {
            background-color: #fefefe;
            margin: 10% auto; /* 10% от верхней границы и по центру */
            padding: 20px;
            border: 1px solid #888;
            width: 50%; /* Ширина модального окна */
            border-radius: 5px;
        }

        #selectMainClassModalContent h2 {
            margin-top: 0;
        }

        #classesList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
        }

        #classesList li {
            padding: 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
        }

        #classesList li:hover {
            background-color: #f1f1f1;
        }

        #closeModal {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Добавим стили для новой кнопки */
        .icon-panel button#select-main-class-button {
            /* Если необходимо, добавьте индивидуальные стили */
        }

        .btn-group {
            display: flex;
            justify-content: center;
            padding: 10px;
            background: #282c34;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        }
/* Светлая тема */
body.light-mode {
    background-color: #ffffff;
    color: #000000;
}

#container.light-mode {
    background-color: #f4f4f4;
}

#sidebar.light-mode {
    background: #eaeaea;
    color: #000000;
    border-right: 1px solid #ccc;
}

#jstree.light-mode {
    border-right: 1px solid #ccc;
}

#editor.light-mode {
    background-color: #ffffff;
    color: #000000;
}

.icon-panel.light-mode button {
    color: #000;
}

.icon-panel.light-mode button:hover {
    color: #0366d6;
}

#compile-output.light-mode {
    background: #f6f6f6;
    color: #333;
    border-top: 1px solid #ccc;
}

    </style>
</head>
<body>
<div id="container">
    <div class="icon-panel">
        <button id="profile-button" title="Profile" data-url="/userProfile">
            <i class="fas fa-user-circle"></i>
        </button>
        <button id="project-button" title="Project Tree">
            <i class="fas fa-project-diagram"></i>
        </button>
        <button id="save-button" title="Save Project">
            <i class="fas fa-save"></i>
        </button>
        <button id="compile-button" title="Compile Code">
            <i class="fas fa-play"></i>
        </button>
        <button id="select-main-class-button" title="Выберите исполняемый файл">
            <i class="fas fa-file-code"></i>
        </button>
        <div id="theme-toggle" class="icon-panel">
            <button id="theme-button" title="Toggle Theme">
                <i class="fas fa-adjust"></i>
            </button>
        </div>
    </div>
    <div id="sidebar">
        <!--        <div id="jstree"></div>-->
        <div id="jstree" data-file-structure="${fileStructure}" data-project-name="${projectName}"></div>

        <!--        <button id="save-button">Сохранить проект</button>-->
    </div>
    <div id="editor-container">
        <div id="main-class-container">
            <label for="main-class-input">Main Class:</label>
            <input type="text" id="main-class-input" name="mainClass" th:value="${mainClass}" />
        </div>
        <div id="editor"></div>
        <div id="compile-output" style="display: none;">
            <h3>Результат компиляции:</h3>
            <pre id="compile-result"></pre>
        </div>
    </div>
</div>
<div id="message"></div>
<div id="selectMainClassModal">
    <div id="selectMainClassModalContent">
        <span id="closeModal">&times;</span>
        <h2>Выберите исполняемый класс</h2>
        <ul id="classesList">
            <!-- Список классов будет динамически заполняться -->
        </ul>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
<script>
    $(document).ready(function() {
        $('#profile-button').on('click', function() {
            const profileUrl = $(this).data('url');
            window.location.href = profileUrl;
        });
    });

    $(function() {
        let editor;
        let currentFile = null;
        const csrfToken = document.querySelector('meta[name="_csrf"]').getAttribute('content');
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');
        const projectId = document.querySelector('meta[name="projectId"]').content;
        let isUndoing = false;
        const undoStack = [];
        let pendingCreations = 0;
        let duplicateNameError = false;
        let isSidebarOpen = true;
        let isSaving = false;

    const initializeSelectMainClassModal = () => {
        const modal = $('#selectMainClassModal');
        const closeModalBtn = $('#closeModal');

        closeModalBtn.on('click', function() {
            modal.hide();
        });

        $(window).on('click', function(event) {
            if ($(event.target).is(modal)) {
                modal.hide();
            }
        });

        $('#select-main-class-button').on('click', function(event) {
            event.stopPropagation();
            fetchClassesWithMain();
        });
    };


     const themeButton = document.getElementById('theme-button');
    const body = document.body;

    const applyTheme = (theme) => {
        if (theme === 'light') {
            body.classList.add('light-mode');
        } else {
            body.classList.remove('light-mode');
        }
        localStorage.setItem('theme', theme); // Сохранить тему
    };

    const savedTheme = localStorage.getItem('theme') || 'dark'; // По умолчанию тёмная
    applyTheme(savedTheme);

    themeButton.addEventListener('click', () => {
        const currentTheme = body.classList.contains('light-mode') ? 'dark' : 'light';
        applyTheme(currentTheme);
    });


    const ensureMainClassName = (mainClassName, projectLanguage) => {
        const languageExtensionMap = {
            'java': '.java',
            'python': '.py',
        };

        const extension = languageExtensionMap[projectLanguage.toLowerCase()] || '';

        if (extension && !mainClassName.toLowerCase().endsWith(extension)) {
            return mainClassName + extension;
        }
        return mainClassName;
    };
    const fetchClassesWithMain = () => {
        $.ajax({
            url: `/projects/${projectId}/classes-with-main`,
            type: 'GET',
            headers: {
                [csrfHeader]: csrfToken
            },
            success: function(mainClasses) {
                populateClassesList(mainClasses);
                $('#selectMainClassModal').show();
            },
            error: function(xhr, status, error) {
                console.error("Ошибка при получении списка классов с main методом:", error);
                showMessage("Не удалось загрузить список классов.", "error");
            }
        });
    };

    const populateClassesList = (mainClasses) => {
        const classesList = $('#classesList');
        classesList.empty();

        if (mainClasses.length === 0) {
            classesList.append('<li>Классы с main методом не найдены</li>');
        } else {
            const projectLanguage = document.querySelector('meta[name="projectLanguage"]').getAttribute('content').toLowerCase();
            const languageExtensionMap = {
                'java': '.java',
                'python': '.py',
            };
            const extension = languageExtensionMap[projectLanguage] || '';

            mainClasses.forEach(function(classItem) {
                const path = classItem.path;
                let mainClassName = path.replace(/\//g, '.').replace(/\.[^.]+$/, '');

                if (extension && !path.toLowerCase().endsWith(extension)) {
                    return;
                }

                if (extension && projectLanguage === 'python') {
                    mainClassName += extension;
                }

                classesList.append(`<li data-class-name="${mainClassName}">${path}</li>`);
            });
        }

        $('#classesList li').on('click', function() {
            const selectedClass = $(this).data('class-name');
            if (selectedClass) {
                setMainClass(selectedClass);
                $('#selectMainClassModal').hide();
            }
        });
    };


    const setMainClass = (mainClassName) => {
        console.log("Установка mainClassName:", mainClassName);

        const projectLanguage = document.querySelector('meta[name="projectLanguage"]').getAttribute('content');

        mainClassName = ensureMainClassName(mainClassName, projectLanguage);

        $.ajax({
            url: `/projects/${projectId}/mainClass`,
            type: 'POST',
            contentType: 'application/json',
            headers: {
                [csrfHeader]: csrfToken
            },
            data: JSON.stringify({ mainClass: mainClassName }),
            success: function(response) {
                console.log("mainClassName успешно установлен:", response);
                showMessage("Главный класс успешно установлен.", "success");
                $('#main-class-input').val(mainClassName);
            },
            error: function(xhr, status, error) {
                console.error("Ошибка при установке mainClassName:", error);
                showMessage("Ошибка при установке главного класса.", "error");
            }
        });
    };

    $('#main-class-input').on('change', function() {
        saveMainClass();
    });

    $('#project-button').on('click', function() {
            if (isSidebarOpen) {
                $('#sidebar').css('width', '0');
                $('#editor-container').css('width', '100%'); // Вернем всю ширину для редактора
                $(this).removeClass('active');
            } else {
                $('#sidebar').css('width', '300px'); // Устанавливаем ширину боковой панели
                $('#editor-container').css('width', 'calc(100% - 300px)'); // Сжимаем редактор, чтобы он не выходил за экран
                $(this).addClass('active');
            }
            isSidebarOpen = !isSidebarOpen;
        });
        $('#compile-button').on('click', function() {
            compileCode();
        });
        const getLanguageFromFilename = (filename) => {
            const extension = filename.split('.').pop().toLowerCase();
            const languageMap = {
                'js': 'javascript',
                'html': 'html',
                'css': 'css',
                'json': 'json',
                'md': 'markdown',
                'py': 'python',
                'java': 'java',
                'c': 'c',
                'cpp': 'cpp',
                'ts': 'typescript',
            };
            return languageMap[extension] || 'plaintext';
        };
        const compileCode = () => {
            const compileButton = $('#compile-button');

            compileButton.prop('disabled', true);
            compileButton.css('opacity', '0.6'); // Визуальное обозначение отключения

            saveProject(false)
                .then(function() {
                    if (!currentFile) {
                        showMessage("Нет открытого файла для компиляции.", "error");
                        compileButton.prop('disabled', false);
                        compileButton.css('opacity', '1');
                        return;
                    }

                    const projectLanguage = document.querySelector('meta[name="projectLanguage"]').getAttribute('content');

                    const mainClassInput = document.getElementById('main-class-input');
                    let mainClassName = mainClassInput.value.trim();
                    if (!mainClassName) {
                        showMessage("Введите название класса для компиляции.", "error");
                        compileButton.prop('disabled', false);
                        compileButton.css('opacity', '1');
                        return;
                    }

                    mainClassName = ensureMainClassName(mainClassName, projectLanguage);

                    const compileRequest = {
                        project_id: Number(projectId),
                        language: projectLanguage,
                        mainClassName: mainClassName
                    };

                    console.log("Отправка compileRequest:", compileRequest);

                    $.ajax({
                        url: '/compile',
                        type: 'POST',
                        contentType: 'application/json',
                        headers: {
                            [csrfHeader]: csrfToken
                        },
                        data: JSON.stringify(compileRequest),
                    })
                    .done(function(response) {
                        console.log("Результат компиляции:", response);
                        displayCompileResult(response);

                        if (response.returnCode === 0) {
                            showMessage("Компиляция завершена успешно.", "success");
                        } else {
                            showMessage("Произошла ошибка при компиляции.", "error");
                        }
                    })
                    .fail(function(xhr, status, error) {
                        console.error("Ошибка при отправке запроса на компиляцию:", error);
                        showMessage("Ошибка при отправке запроса на компиляцию.", "error");
                    })
                    .always(function() {
                        compileButton.prop('disabled', false);
                        compileButton.css('opacity', '1');
                    });
                })
                .fail(function() {
                    compileButton.prop('disabled', false);
                    compileButton.css('opacity', '1');
                    showMessage("Не удалось сохранить проект перед компиляцией.", "error");
                });
        };


        const displayCompileResult = (result) => {
            console.log("Display compile result:", result);
            $('#compile-output').show();

            let output = "";

            if (result.stderr && result.stderr.length > 0) {
                result.stderr.forEach(error => {
                    output += `${error.message}\n`;
                    if (error.file) {
                        output += `File: ${error.file}\n`;
                    }
                    if (error.line && error.line > 0) {
                        output += `Line: ${error.line}\n`;
                    }
                    if (error.column && error.column > 0) {
                        output += `Column: ${error.column}\n`;
                    }
                    output += "\n";
                });
            }

            if (result.stdout && result.stdout.trim() !== "") {
                output += result.stdout;
            }

            if (output.trim() === "") {
                output = "Нет вывода.";
            }

            output += `\nПрограмма завершилась с кодом ${result.returnCode}.`;

            $('#compile-result').text(output);
        };





        const showMessage = (msg, type = 'error') => {
            const messageDiv = $('#message');
            messageDiv.text(msg);
            messageDiv.removeClass('message-success message-error');
            if (type === 'success') {
                messageDiv.addClass('message-success');
            } else {
                messageDiv.addClass('message-error');
            }
            messageDiv.fadeIn(500).delay(2000).fadeOut(500);
        };
        const isValidName = (name) => {
            if (!name || typeof name !== 'string') {
                return false;
            }
            const trimmedName = name.trim();
            if (trimmedName.length === 0) {
                return false;
            }
            const invalidPatterns = ['/', '\\', '..'];
            for (const pattern of invalidPatterns) {
                if (trimmedName.startsWith(pattern) || trimmedName.includes(pattern)) {
                    return false;
                }
            }
            const prohibitedChars = ['<', '>', ':', '"', '|', '?', '*', '\0'];
            for (const char of prohibitedChars) {
                if (trimmedName.includes(char)) {
                    return false;
                }
            }
            return true;
        };
        const saveCurrentFile = () => {
            if (currentFile && editor) {
                const newContent = editor.getValue();
                if (currentFile.data.content !== newContent) {
                    currentFile.data.content = newContent;
                    console.log(`Содержимое файла "${currentFile.text}" сохранено.`);
                }
            }
        };
        const clearEditorIfDeleted = (node) => {
            if (currentFile && node.id === currentFile.id) {
                editor.setValue('');
                currentFile = null;
                console.log(`Файл "${node.text}" удалён. Редактор очищен.`);
                return;
            }
            if (node.type === 'folder' && node.children && node.children.length > 0) {
                const tree = $('#jstree').jstree(true);
                node.children.forEach(childId => {
                    const child = tree.get_node(childId);
                    clearEditorIfDeleted(child);
                });
            }
        };
        const checkUniqueName = (node, name, type, excludeId = null) => {
            const tree = $('#jstree').jstree(true);
            const childIds = tree.get_node(node.id).children;
            let isUnique = true;
            childIds.forEach(function(childId) {
                const childNode = tree.get_node(childId);
                const childText = childNode.text.trim();
                const childType = childNode.type;
                if (childText.toLowerCase() === name.trim().toLowerCase() && childType === type) {
                    if (excludeId && childId === excludeId) {
                        return;
                    }
                    isUnique = false;
                    return false;
                }
            });
            return isUnique;
        };
        const getFullPath = (node) => {
            const tree = $('#jstree').jstree(true);
            const path = [];
            let current = node;
            while (current && current.id !== "#") {
                path.unshift(current.text);
                current = tree.get_node(current.parent);
            }
            path.shift();
            return path.join('/');
        };
        const gatherFiles = (node) => {
            const tree = $('#jstree').jstree(true);
            const files = [];
            node.children.forEach(childId => {
                const child = tree.get_node(childId);
                const fileObj = {
                    id: child.id,
                    text: child.text,
                    path: getFullPath(child),
                    type: child.type,
                    data: child.type === 'file' ? { content: child.data.content || "" } : undefined,
                    state: child.state,
                    files: child.type === 'folder' ? gatherFiles(child) : undefined
                };
                files.push(fileObj);
            });
            return files;
        };
        const mapToBackendFormat = (gatheredFiles) => {
            return gatheredFiles.map(fileObj => {
                const mappedObj = {
                    path: fileObj.path,
                    content: fileObj.type === 'file' ? fileObj.data.content : null,
                    type: fileObj.type === 'folder' ? 'folder' : null
                };
                if (fileObj.type === 'folder') {
                    mappedObj.files = fileObj.files && fileObj.files.length > 0 ? mapToBackendFormat(fileObj.files) : [];
                }
                return mappedObj;
            });
        };
        const getProjectJSON = () => {
            const tree = $('#jstree').jstree(true);
            const root = tree.get_node("root");
            const gatheredFiles = gatherFiles(root);
            const mappedFiles = mapToBackendFormat(gatheredFiles);
            const project = {
                files: mappedFiles
            };
            return project;
        };
        const saveProject = (showSuccessMessage = true) => {
            if (isSaving) {
                console.log("Сохранение уже выполняется, пропуск текущего цикла автосохранения.");
                return $.Deferred().resolve().promise(); // Возвращаем уже выполненный промис
            }
            isSaving = true;
            saveCurrentFile();
            const projectJSON = getProjectJSON();
            console.log("Сформированный JSON проекта:", JSON.stringify(projectJSON, null, 2));
            if (!projectJSON.files || projectJSON.files.length === 0) {
                console.log("Проект пустой, сохранение не требуется.");
                isSaving = false;
                return $.Deferred().resolve().promise();
            }
            return $.ajax({
                url: `/projects/${projectId}/save`,
                type: 'POST',
                contentType: 'application/json',
                headers: {
                    [csrfHeader]: csrfToken
                },
                data: JSON.stringify(projectJSON),
            })
            .done(function(response) {
                console.log("Проект успешно сохранён!");
                if (showSuccessMessage) {
                    showMessage("Проект успешно сохранён!", "success");
                }
            })
            .fail(function(xhr, status, error) {
                console.error("Ошибка при сохранении проекта:", error);
                showMessage("Ошибка при сохранении проекта.", "error");
            })
            .always(function() {
                isSaving = false;
            });
        };

        const createNodeRecursively = (parent, nodeData, position) => {
            const tree = $('#jstree').jstree(true);
            position = (typeof position === 'number' && position < 0) ? 'last' : position;
            pendingCreations++;
            console.log(`Восстанавливаем узел: ${nodeData.text}, Тип: ${nodeData.type}, ID: ${nodeData.id}`);
            tree.create_node(parent, {
                id: nodeData.id,
                text: nodeData.text,
                type: nodeData.type,
                data: nodeData.type === 'file' ? { content: nodeData.data.content || "" } : {},
                state: nodeData.state
            }, position, function(new_node) {
                console.log(`Узел "${new_node.text}" восстановлен.`);
                if (nodeData.files && nodeData.files.length > 0) {
                    nodeData.files.forEach(child => {
                        createNodeRecursively(new_node.id, child, 'last');
                    });
                }
                pendingCreations--;
                if (pendingCreations === 0) {
                    isUndoing = false;
                    console.log("Восстановление всех узлов завершено.");
                }
            });
        };
        const loadFile = (node) => {
            if (node.type === 'file') {
                const content = node.data && node.data.content ? node.data.content : "";
                const language = getLanguageFromFilename(node.text);
                if (editor) {
                    isUndoing = true;
                    const currentModel = editor.getModel();
                    if (currentModel) {
                        monaco.editor.setModelLanguage(currentModel, language);
                        editor.setValue(content);
                    }
                    isUndoing = false;
                    console.log(`Файл "${node.text}" загружен в редактор с языком "${language}".`);
                }
                currentFile = node;
            }
        };
        const undo = () => {
            if (undoStack.length === 0) {
                console.log("Undo Stack пуст.");
                return;
            }
            const lastAction = undoStack.pop();
            console.log("Undoing Action:", lastAction);
            isUndoing = true;
            const tree = $('#jstree').jstree(true);
            switch(lastAction.action) {
                case 'delete':
                    tree.delete_node(lastAction.node);
                    break;
                case 'create':
                    createNodeRecursively(lastAction.parent, lastAction.node, lastAction.position);
                    break;
                case 'rename':
                    tree.rename_node(lastAction.node, lastAction.old_text);
                    break;
                case 'move':
                    tree.move_node(lastAction.node, lastAction.old_parent, lastAction.old_position);
                    break;
                default:
                    console.warn('Неизвестное действие для отмены:', lastAction.action);
            }
        };
        const handleRename = (data) => {
            console.log(`handleRename вызван для узла: ${data.node.id}, Тип: ${data.node.type}, Старое имя: ${data.old}, Новое имя: ${data.text}`);
            if (!isUndoing) {
                if (data.node.id === "root") {
                    showMessage("Нельзя переименовывать корневую папку!");
                    const tree = $('#jstree').jstree(true);
                    tree.rename_node(data.node, data.old);
                    return;
                }
                if (!isValidName(data.text)) {
                    showMessage("Недопустимое имя.");
                    const tree = $('#jstree').jstree(true);
                    tree.rename_node(data.node, data.old);
                    return;
                }
                const parent = data.node.parent;
                const tree = $('#jstree').jstree(true);
                const siblings = tree.get_node(parent).children;
                let isUnique = true;
                siblings.forEach(function(childId) {
                    const childNode = tree.get_node(childId);
                    const childText = childNode.text.trim();
                    const childType = childNode.type;
                    if (childText.toLowerCase() === data.text.trim().toLowerCase() && childType === data.node.type && childId !== data.node.id) {
                        isUnique = false;
                        return false;
                    }
                });
                if (!isUnique) {
                    showMessage("Узел с таким именем уже существует в этой папке.");
                    tree.rename_node(data.node, data.old);
                    return;
                }
                undoStack.push({
                    action: 'rename',
                    node: data.node.id,
                    old_text: data.old,
                    new_text: data.text
                });
                console.log("Action Recorded to Undo Stack:", { action: 'rename', node: data.node.id, old_text: data.old, new_text: data.text });
            }
            if (currentFile && data.node.id === currentFile.id && currentFile.type === 'file') {
                const newLanguage = getLanguageFromFilename(data.text);
                monaco.editor.setModelLanguage(editor.getModel(), newLanguage);
                console.log(`Язык синтаксиса обновлён на "${newLanguage}" для файла "${data.text}".`);
            }
        };
        const isMoveNameUnique = (targetNode, node) => {
            const tree = $('#jstree').jstree(true);
            const childIds = tree.get_node(targetNode.id).children;
            let isUnique = true;
            childIds.forEach(function(childId) {
                const childNode = tree.get_node(childId);
                const childText = childNode.text.trim();
                const childType = childNode.type;
                if (childText.toLowerCase() === node.text.trim().toLowerCase() && childType === node.type) {
                    if (childId === node.id) {
                        return;
                    }
                    isUnique = false;
                    return false;
                }
            });
            return isUnique;
        };
        const initializeJsTree = () => {
            const fileStructureJson = document.querySelector('meta[name="fileStructure"]').getAttribute('content');
             const projectName = $('#jstree').data('project-name');
            let fileTreeData = [];
            if (fileStructureJson) {
                try {
                    fileTreeData = JSON.parse(fileStructureJson);
                } catch (e) {
                    console.error("Ошибка при парсинге JSON для fileStructure:", e);
                }
            }
            if (!fileTreeData || fileTreeData.length === 0) {
                fileTreeData = [{
                    id: "root",
                    text: projectName ||"Проект",
                    type: "folder",
                    children: [],
                    state: { opened: true }
                }];
            }
            $('#jstree').jstree({
                core: {
                    check_callback: function (operation, node, parent, position, more) {
                        const tree = $('#jstree').jstree(true);
                        if (operation === "move_node") {
                            const movingNode = node;
                            const targetParentNode = tree.get_node(parent);
                            if (movingNode.id === "root") {
                                return false;
                            }
                            if (targetParentNode.type !== "folder") {
                                return false;
                            }
                            if (parent === "#") {
                                return false;
                            }
                            if (!isMoveNameUnique(targetParentNode, movingNode)) {
                                return false;
                            }
                        }
                        return true;
                    },
                    data: fileTreeData
                },
                plugins: ['contextmenu', 'dnd', 'types'],
                types: {
                    folder: { icon: 'jstree-folder' },
                    file: { icon: 'jstree-file' }
                },
                contextmenu: {
                    items: function(node) {
                        const tree = $("#jstree").jstree(true);
                        const menuItems = {};
                        if (node.type !== 'folder') {
                            menuItems.Rename = {
                                separator_before: false,
                                separator_after: false,
                                label: "Переименовать",
                                action: function () { tree.edit(node); }
                            };
                            menuItems.Remove = {
                                separator_before: false,
                                separator_after: false,
                                label: "Удалить",
                                action: function () {
                                    if (node.id === "root") {
                                        return;
                                    }
                                    const parent = node.parent;
                                    const parentNode = tree.get_node(parent);
                                    const position = parentNode.children.indexOf(node.id) !== -1 ? parentNode.children.indexOf(node.id) : 'last';
                                    if (!isUndoing) {
                                        const fullNodeData = {
                                            id: node.id,
                                            text: node.text,
                                            type: node.type,
                                            data: node.type === 'file' ? { content: node.data.content || "" } : undefined,
                                            state: node.state,
                                            files: node.type === 'folder' ? gatherFiles(node) : undefined
                                        };
                                        undoStack.push({
                                            action: 'create',
                                            node: fullNodeData,
                                            parent: parent,
                                            position: position
                                        });
                                        console.log("Action Recorded to Undo Stack:", { action: 'create', node: fullNodeData, parent: parent, position: position });
                                    }
                                    clearEditorIfDeleted(node);
                                    tree.delete_node(node);
                                }
                            };
                        } else {
                            menuItems.Create = {
                                separator_before: false,
                                separator_after: false,
                                label: "Создать",
                                action: false,
                                submenu: {
                                    CreateFile: {
                                        label: "Файл",
                                        action: function () {
                                            const newFileName = prompt("Введите имя нового файла:", "Новый файл.js");
                                            if (!newFileName) {
                                                return;
                                            }
                                            if (!isValidName(newFileName)) {
                                                showMessage("Недопустимое имя файла.");
                                                return;
                                            }
                                            if (!checkUniqueName(node, newFileName, 'file')) {
                                                showMessage("Файл с таким именем уже существует в этой папке.");
                                                return;
                                            }
                                            const newId = 'file_' + Date.now();
                                            tree.create_node(node, {
                                                id: newId,
                                                text: newFileName,
                                                type: "file",
                                                data: { content: "" },
                                                state: { opened: true }
                                            }, "last", function(new_node) {
                                                setTimeout(function() {
                                                    tree.select_node(new_node);
                                                }, 0);
                                            });
                                        }
                                    },
                                    CreateFolder: {
                                        label: "Папка",
                                        action: function () {
                                            const newFolderName = prompt("Введите имя новой папки:", "Новая папка");
                                            if (!newFolderName) {
                                                return;
                                            }
                                            if (!isValidName(newFolderName)) {
                                                showMessage("Недопустимое имя папки.");
                                                return;
                                            }
                                            if (!checkUniqueName(node, newFolderName, 'folder')) {
                                                showMessage("Папка с таким именем уже существует в этой папке.");
                                                return;
                                            }
                                            const newId = 'folder_' + Date.now();
                                            tree.create_node(node, {
                                                id: newId,
                                                text: newFolderName,
                                                type: "folder",
                                                state: { opened: true }
                                            }, "last", function(new_node) {
                                                setTimeout(function() {
                                                    tree.select_node(new_node);
                                                }, 0);
                                            });
                                        }
                                    }
                                }
                            };
                            if (node.id !== "root") {
                                menuItems.Rename = {
                                    separator_before: false,
                                    separator_after: false,
                                    label: "Переименовать",
                                    action: function () {
                                        tree.edit(node);
                                    }
                                };
                                menuItems.Remove = {
                                    separator_before: false,
                                    separator_after: false,
                                    label: "Удалить",
                                    action: function () {
                                        if (node.id === "root") {
                                            return;
                                        }
                                        const parent = node.parent;
                                        const parentNode = tree.get_node(parent);
                                        const position = parentNode.children.indexOf(node.id) !== -1 ? parentNode.children.indexOf(node.id) : 'last';
                                        if (!isUndoing) {
                                            const fullNodeData = {
                                                id: node.id,
                                                text: node.text,
                                                type: node.type,
                                                data: node.type === 'file' ? { content: node.data.content || "" } : undefined,
                                                state: node.state,
                                                files: node.type === 'folder' ? gatherFiles(node) : undefined
                                            };
                                            undoStack.push({
                                                action: 'create',
                                                node: fullNodeData,
                                                parent: parent,
                                                position: position
                                            });
                                            console.log("Action Recorded to Undo Stack:", { action: 'create', node: fullNodeData, parent: parent, position: position });
                                        }
                                        clearEditorIfDeleted(node);
                                        tree.delete_node(node);
                                    }
                                };
                            }
                        }
                        return menuItems;
                    }
                }
            })
            .on('create_node.jstree', function (e, data) {
                if (data.node.type === 'file' && !isUndoing) {
                    data.node.data = { "content": "" };
                }
                if (!isUndoing) {
                    undoStack.push({
                        action: 'delete',
                        node: data.node.id
                    });
                    console.log("Action Recorded to Undo Stack:", { action: 'delete', node: data.node.id });
                }
            })
            .on('rename_node.jstree', function (e, data) {
                handleRename(data);
            })
            .on('delete_node.jstree', function (e, data) {
                clearEditorIfDeleted(data.node);
            })
            .on('move_node.jstree', function (e, data) {
                if (!isUndoing) {
                    undoStack.push({
                        action: 'move',
                        node: data.node.id,
                        old_parent: data.old_parent,
                        old_position: data.old_position
                    });
                    console.log("Action Recorded to Undo Stack:", { action: 'move', node: data.node.id, old_parent: data.old_parent, old_position: data.old_position });
                }
            })
            .on('dnd_stop.vakata', function (e, data) {
                if (duplicateNameError) {
                    showMessage("В целевой папке уже существует узел с таким именем.");
                    duplicateNameError = false;
                }
            })
            .on('select_node.jstree', function (e, data) {
                saveCurrentFile();
                if (data.node.type === 'file') {
                    loadFile(data.node);
                }
            });
            $(document).on('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    console.log("Ctrl+Z нажато");
                    undo();
                }
            });
            $('#save-button').on('click', function() {
                saveProject();
            });
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }});
            require(['vs/editor/editor.main'], function() {
                editor = monaco.editor.create(document.getElementById('editor'), {
                    value: '',
                    language: 'plaintext',
                    theme: localStorage.getItem('theme') === 'light' ? 'vs' : 'vs-dark',
                    automaticLayout: true
                });
                document.getElementById('theme-button').addEventListener('click', () => {
        const newTheme = body.classList.contains('light-mode') ? 'vs' : 'vs-dark';
        monaco.editor.setTheme(newTheme);
    });
                editor.onDidChangeModelContent(function() {
                    if (isUndoing) {
                        return;
                    }
                    if (currentFile) {
                        currentFile.data.content = editor.getValue();
                        console.log(`Содержимое файла "${currentFile.text}" обновлено.`);
                    }
                });
            });
        };
        initializeSelectMainClassModal();
        initializeJsTree();
        setInterval(function() {
            console.log("Автосохранение проекта...");
            saveProject(false);
        }, 15000);
    });
</script>
</body>
</html>