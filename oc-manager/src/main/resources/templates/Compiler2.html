<!DOCTYPE html>
<html lang="en" xmlns:sec="http://www.w3.org/1999/xhtml" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="projectId" th:content="${projectId}">
    <meta name="_csrf" th:content="${_csrf.token}" />
    <meta name="_csrf_header" th:content="${_csrf.headerName}" />
    <meta name="fileNames" th:content="${files}">
    <title>jsTree и Monaco Editor</title>
    <!-- Подключение стилей jsTree -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 25%;
            border-right: 1px solid #ccc;
            overflow: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #jstree {
            flex: 1;
            overflow: auto;
            min-height: 200px; /* Добавлено */
        }
        #save-button {
            margin-top: 10px;
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #save-button:hover {
            background-color: #218838;
        }
        #editor-container {
            width: 75%;
            position: relative;
        }
        #editor {
            width: 100%;
            height: 100%;
        }
        /* Контекстное меню */
        .jstree-contextmenu {
            z-index: 1000;
        }
        /* Уведомления */
        #message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            display: none;
            z-index: 1001;
        }
        /* Иконки для папок и файлов */
        .jstree-folder {
            background: url('https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default-folder.png') no-repeat center center;
            background-size: 16px 16px;
        }

        .jstree-file {
            background: url('https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default-file.png') no-repeat center center;
            background-size: 16px 16px;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="sidebar">
        <div id="jstree"></div>
        <button id="save-button">Сохранить проект</button>
    </div>
    <div id="editor-container">
        <div id="editor"></div>
    </div>
</div>
<!-- Уведомления -->
<div id="message"></div>

<!-- Подключение библиотек -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
<!-- Monaco Editor -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
<script>
    $(function() {
        let editor;
        let currentFile = null;
        const csrfToken = document.querySelector('meta[name="_csrf"]').getAttribute('content');
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');
        const projectId = document.querySelector('meta[name="projectId"]').content;
        let isUndoing = false; // Флаг для предотвращения записи действий при выполнении отмены
        const undoStack = [];
        let pendingCreations = 0; // Счётчик ожидающих операций создания узлов
        let duplicateNameError = false; // Флаг для отслеживания ошибки дублирования имени

        /**
         * Функция для определения языка на основе расширения файла
         * @param {string} filename - Имя файла
         * @returns {string} - Язык программирования для Monaco Editor
         */
        const getLanguageFromFilename = (filename) => {
            const extension = filename.split('.').pop().toLowerCase();
            const languageMap = {
                'js': 'javascript',
                'html': 'html',
                'css': 'css',
                'json': 'json',
                'md': 'markdown',
                'py': 'python',
                'java': 'java',
                'c': 'c',
                'cpp': 'cpp',
                'ts': 'typescript',
                // Добавьте другие расширения и соответствующие языки по мере необходимости
            };
            return languageMap[extension] || 'plaintext';
        };

        /**
         * Функция для отображения уведомлений
         * @param {string} msg - Сообщение для отображения
         */
        const showMessage = (msg) => {
            const messageDiv = $('#message');
            messageDiv.text(msg).fadeIn(500).delay(2000).fadeOut(500);
        };

        /**
         * Функция для сохранения текущего файла перед переключением
         */
        const saveCurrentFile = () => {
            if (currentFile && editor) {
                const newContent = editor.getValue();
                if (currentFile.data.content !== newContent) {
                    currentFile.data.content = newContent;
                    console.log(`Содержимое файла "${currentFile.text}" сохранено.`);
                }
            }
        };

        /**
         * Функция для очистки редактора, если удалённый файл был текущим
         * @param {object} node - Узел jsTree
         */
        const clearEditorIfDeleted = (node) => {
            // Проверяем, является ли удаляемый узел текущим файлом
            if (currentFile && node.id === currentFile.id) {
                editor.setValue('');
                currentFile = null;
                console.log(`Файл "${node.text}" удалён. Редактор очищен.`);
                return;
            }

            // Если удаляется папка, проверяем её содержимое на наличие текущего файла
            if (node.type === 'folder' && node.children && node.children.length > 0) {
                const tree = $('#jstree').jstree(true);
                node.children.forEach(childId => {
                    const child = tree.get_node(childId);
                    clearEditorIfDeleted(child);
                });
            }
        };

        /**
         * Функция для проверки уникальности имени при создании/переименовании
         * @param {object} node - Родительский узел
         * @param {string} name - Имя файла/папки
         * @param {string} type - Тип узла ('file' или 'folder')
         * @param {string} [excludeId] - ID узла, который должен быть исключен из проверки (например, при перемещении)
         * @returns {boolean} - true, если имя уникально для данного типа, иначе false
         */
        const checkUniqueName = (node, name, type, excludeId = null) => {
            const tree = $('#jstree').jstree(true);
            const children = tree.get_children_dom(node.id);
            let isUnique = true;

            children.each(function() {
                const childId = $(this).attr('id');
                const childNode = tree.get_node(childId);
                const childText = childNode.text.trim();
                const childType = childNode.type;

                if (childText.toLowerCase() === name.trim().toLowerCase() && childType === type) {
                    if (excludeId && childId === excludeId) {
                        // Это тот же узел, поэтому не считаем его дубликатом
                        return;
                    }
                    isUnique = false;
                    return false; // Прерываем цикл
                }
            });

            return isUnique;
        };

        /**
         * Функция для получения полного пути узла
         * @param {object} node - Узел jsTree
         * @returns {string} - Полный путь узла
         */
        const getFullPath = (node) => {
            const tree = $('#jstree').jstree(true);
            const path = [];
            let current = node;

            while (current && current.id !== "#") {
                path.unshift(current.text);
                current = tree.get_node(current.parent);
            }

            // Удаляем корневую папку из пути
            path.shift();

            return path.join('/');
        };

        /**
         * Рекурсивная функция для сбора информации о файлах и папках
         * @param {object} node - Узел jsTree
         * @returns {Array} - Массив объектов с информацией о файлах и папках
         */
        const gatherFiles = (node) => {
            const tree = $('#jstree').jstree(true);
            const files = [];

            node.children.forEach(childId => {
                const child = tree.get_node(childId);
                const fileObj = {
                    id: child.id,             // Добавлено: id узла
                    text: child.text,         // Добавлено: text узла
                    path: getFullPath(child),
                    type: child.type,         // Изменено: всегда устанавливаем type
                    data: child.type === 'file' ? { content: child.data.content || "" } : undefined,
                    state: child.state,       // Добавлено: state узла
                    files: child.type === 'folder' ? gatherFiles(child) : undefined
                };

                files.push(fileObj);
            });

            return files;
        };

        /**
         * Функция для преобразования данных из gatherFiles в формат, ожидаемый бэкэндом
         * @param {Array} gatheredFiles - Массив файлов и папок, собранных функцией gatherFiles
         * @returns {Array} - Преобразованный массив без поля state
         */
        const mapToBackendFormat = (gatheredFiles) => {
            return gatheredFiles.map(fileObj => {
                const mappedObj = {
                    path: fileObj.path,
                    content: fileObj.type === 'file' ? fileObj.data.content : null,
                    type: fileObj.type === 'folder' ? 'folder' : null
                };

                if (fileObj.type === 'folder') {
                    mappedObj.files = fileObj.files && fileObj.files.length > 0 ? mapToBackendFormat(fileObj.files) : [];
                }

                return mappedObj;
            });
        };

        /**
         * Функция для получения JSON объекта проекта, готового для отправки на бэкэнд
         * @returns {object} - JSON объект проекта без поля state
         */
        const getProjectJSON = () => {
            const tree = $('#jstree').jstree(true);
            const root = tree.get_node("root");
            const gatheredFiles = gatherFiles(root);
            const mappedFiles = mapToBackendFormat(gatheredFiles);
            const project = {
                files: mappedFiles
            };
            return project;
        };

        /**
         * Функция для отправки проекта на бэкэнд
         */
        const saveProject = () => {
            const projectJSON = getProjectJSON();
            console.log("Сформированный JSON проекта:", JSON.stringify(projectJSON, null, 2));

            $.ajax({
                url: `/projects/${projectId}/save`,
                type: 'POST',
                contentType: 'application/json',
                headers: {
                    [csrfHeader]: csrfToken
                },
                data: JSON.stringify(projectJSON),
                success: function(response) {
                    showMessage("Проект успешно сохранён!");
                    console.log("Ответ от сервера:", response);
                },
                error: function(xhr, status, error) {
                    showMessage("Ошибка при сохранении проекта.");
                    console.error("Ошибка:", error);
                }
            });
        };

        /**
         * Рекурсивная функция для создания узлов и их дочерних элементов
         * @param {string} parent - ID родительского узла
         * @param {object} nodeData - Данные узла для создания
         * @param {number|string} position - Позиция для вставки узла
         */
        const createNodeRecursively = (parent, nodeData, position) => {
            const tree = $('#jstree').jstree(true);
            position = (typeof position === 'number' && position < 0) ? 'last' : position;

            pendingCreations++;

            // Добавим логирование для отладки
            console.log(`Восстанавливаем узел: ${nodeData.text}, Тип: ${nodeData.type}, ID: ${nodeData.id}`);

            tree.create_node(parent, {
                id: nodeData.id,
                text: nodeData.text,
                type: nodeData.type,
                data: nodeData.type === 'file' ? { content: nodeData.data.content || "" } : {},
                state: nodeData.state
            }, position, function(new_node) {
                console.log(`Узел "${new_node.text}" восстановлен.`);

                if (nodeData.files && nodeData.files.length > 0) {
                    nodeData.files.forEach(child => {
                        createNodeRecursively(new_node.id, child, 'last');
                    });
                }

                pendingCreations--;
                if (pendingCreations === 0) {
                    isUndoing = false;
                    console.log("Восстановление всех узлов завершено.");
                }
            });
        };

        /**
         * Функция для загрузки файла в редактор
         * @param {object} node - Узел jsTree
         */
        const loadFile = (node) => {
            if (node.type === 'file') {
                const content = node.data.content || "";
                const language = getLanguageFromFilename(node.text);

                if (editor) {
                    isUndoing = true; // Устанавливаем флаг перед изменением модели
                    const currentModel = editor.getModel();
                    if (currentModel) {
                        monaco.editor.setModelLanguage(currentModel, language);
                        editor.setValue(content);
                    }
                    isUndoing = false; // Сбрасываем флаг после изменения модели
                    console.log(`Файл "${node.text}" загружен в редактор с языком "${language}".`);
                }

                currentFile = node;
            }
            // При выборе папки ничего не делаем с редактором
        };

        /**
         * Функция Отмены (Undo)
         */
        const undo = () => {
            if (undoStack.length === 0) {
                console.log("Undo Stack пуст.");
                return;
            }
            const lastAction = undoStack.pop();
            console.log("Undoing Action:", lastAction);
            isUndoing = true; // Устанавливаем флаг

            const tree = $('#jstree').jstree(true);

            switch(lastAction.action) {
                case 'delete':
                    tree.delete_node(lastAction.node);
                    break;
                case 'create':
                    // Восстанавливаем узел и его детей
                    createNodeRecursively(lastAction.parent, lastAction.node, lastAction.position);
                    break;
                case 'rename':
                    tree.rename_node(lastAction.node, lastAction.old_text);
                    break;
                case 'move':
                    tree.move_node(lastAction.node, lastAction.old_parent, lastAction.old_position);
                    break;
                default:
                    console.warn('Неизвестное действие для отмены:', lastAction.action);
            }
        };

        /**
         * Функция для обработки переименования узла
         * @param {object} data - Данные события
         */
        const handleRename = (data) => {
            console.log(`handleRename вызван для узла: ${data.node.id}, Тип: ${data.node.type}, Старое имя: ${data.old}, Новое имя: ${data.text}`);

            if (!isUndoing) {
                // Предотвращение переименования корневой папки
                if (data.node.id === "root") {
                    showMessage("Нельзя переименовывать корневую папку!");
                    const tree = $('#jstree').jstree(true);
                    tree.rename_node(data.node, data.old);
                    return;
                }

                // Проверка уникальности имени при переименовании
                const parent = data.node.parent;
                const tree = $('#jstree').jstree(true);
                const siblings = tree.get_children_dom(parent);
                let isUnique = true;

                siblings.each(function() {
                    const childId = $(this).attr('id');
                    const childNode = tree.get_node(childId);
                    const childText = childNode.text.trim();
                    const childType = childNode.type;

                    if (childText.toLowerCase() === data.text.trim().toLowerCase() && childType === data.node.type && childId !== data.node.id) {
                        isUnique = false;
                        return false; // Прерываем цикл
                    }
                });

                if (!isUnique) {
                    showMessage("Узел с таким именем уже существует в этой папке.");
                    // Удаляем узел, если это созданный пользователем новый файл или папка
                    const nodeId = data.node.id;
                    // Предполагаем, что новые файлы имеют префикс 'file_' и новые папки 'folder_'
                    if (nodeId.startsWith('file_') || nodeId.startsWith('folder_')) {
                        tree.delete_node(data.node);
                    } else {
                        // Если это не новый файл или папка, просто возвращаем старое имя
                        tree.rename_node(data.node, data.old);
                    }
                    return;
                }

                // Записываем обратное действие в стек отмены
                undoStack.push({
                    action: 'rename',
                    node: data.node.id,
                    old_text: data.old,
                    new_text: data.text
                });
                console.log("Action Recorded to Undo Stack:", { action: 'rename', node: data.node.id, old_text: data.old, new_text: data.text });
            }

            // Если переименовываемый узел — текущий файл, обновляем язык синтаксиса
            if (currentFile && data.node.id === currentFile.id && currentFile.type === 'file') {
                const newLanguage = getLanguageFromFilename(data.text);
                monaco.editor.setModelLanguage(editor.getModel(), newLanguage);
                console.log(`Язык синтаксиса обновлён на "${newLanguage}" для файла "${data.text}".`);
            }
        };

        /**
         * Функция для проверки уникальности имени при перемещении узла
         * @param {object} targetNode - Целевой узел jsTree
         * @param {object} node - Перемещаемый узел jsTree
         * @returns {boolean} - true, если имя уникально в целевой папке для данного типа, иначе false
         */
        const isMoveNameUnique = (targetNode, node) => {
            const tree = $('#jstree').jstree(true);
            const children = tree.get_children_dom(targetNode.id);
            let isUnique = true;

            children.each(function() {
                const childId = $(this).attr('id');
                const childNode = tree.get_node(childId);
                const childText = childNode.text.trim();
                const childType = childNode.type;

                if (childText.toLowerCase() === node.text.trim().toLowerCase() && childType === node.type) {
                    if (childId === node.id) {
                        // Это тот же узел, поэтому не считаем его дубликатом
                        return;
                    }
                    isUnique = false;
                    return false; // Прерываем цикл
                }
            });

            return isUnique;
        };

        /**
         * Инициализация jsTree с данными, содержащими содержимое файлов
         */
        $('#jstree').jstree({
            core: {
                check_callback: function (operation, node, parent, position, more) {
                    const tree = $('#jstree').jstree(true);

                    if (operation === "move_node") {
                        const movingNode = node;
                        const targetParentNode = tree.get_node(parent);

                        // 1. Запрет на перемещение корневой папки
                        if (movingNode.id === "root") {
                            showMessage("Нельзя перемещать корневую папку!");
                            return false;
                        }

                        // 2. Запрет на перемещение в файлы
                        if (targetParentNode.type !== "folder") {
                            // showMessage("Нельзя перемещать узел в файл!");
                            return false;
                        }

                        // 3. Проверка уникальности имени в целевой папке для данного типа
                        if (!isMoveNameUnique(targetParentNode, movingNode)) {
                            // Убираем отображение ошибки
                            // showMessage(`В целевой папке уже существует ${movingNode.type === 'folder' ? 'папка' : 'файл'} с именем "${movingNode.text}".`);
                            return false;
                        }
                    }

                    return true; // Разрешаем все остальные операции
                },
                data: [
                    {
                        id: "root",
                        text: "Проект",
                        type: "folder",
                        children: [
                            {
                                id: "file1",
                                text: "index.html",
                                type: "file",
                                data: {
                                    content: `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
</head>
<body>
<h1>Hello World</h1>
</body>
</html>`
                                },
                                state: { opened: true }
                            },
                            {
                                id: "file2",
                                text: "style.css",
                                type: "file",
                                data: {
                                    content: `body { font-family: Arial, sans-serif; }`
                                },
                                state: { opened: true }
                            },
                            {
                                id: "folder1",
                                text: "scripts",
                                type: "folder",
                                children: [
                                    {
                                        id: "file3",
                                        text: "app.js",
                                        type: "file",
                                        data: {
                                            content: `console.log('Hello from app.js');`
                                        },
                                        state: { opened: true }
                                    }
                                ],
                                state: { opened: true }
                            }
                        ],
                        state: { opened: true }
                    }
                ]
            },
            plugins: ['contextmenu', 'dnd', 'types'],
            types: {
                folder: { icon: 'https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default-folder.png' }, // Исправлено
                file: { icon: 'https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default-file.png' } // Исправлено
            },
            contextmenu: {
                items: function(node) {
                    const tree = $("#jstree").jstree(true);
                    const menuItems = {};

                    if (node.type !== 'folder') {
                        // Действия для файлов
                        menuItems.Rename = {
                            separator_before: false,
                            separator_after: false,
                            label: "Переименовать",
                            action: function () { tree.edit(node); }
                        };
                        menuItems.Remove = {
                            separator_before: false,
                            separator_after: false,
                            label: "Удалить",
                            action: function () {
                                if (node.id === "root") {
                                    return;
                                }
                                const parent = node.parent;
                                const parentNode = tree.get_node(parent);
                                const position = parentNode.children.indexOf(node.id) !== -1 ? parentNode.children.indexOf(node.id) : 'last';

                                if (!isUndoing) {
                                    const fullNodeData = {
                                        id: node.id,             // Добавлено: id узла
                                        text: node.text,         // Добавлено: text узла
                                        type: node.type,
                                        data: node.type === 'file' ? { content: node.data.content || "" } : undefined,
                                        state: node.state,
                                        files: node.type === 'folder' ? gatherFiles(node) : undefined
                                    };
                                    undoStack.push({
                                        action: 'create',
                                        node: fullNodeData,
                                        parent: parent,
                                        position: position
                                    });
                                    console.log("Action Recorded to Undo Stack:", { action: 'create', node: fullNodeData, parent: parent, position: position });
                                }

                                // Очистка редактора, если удаляется текущий файл
                                clearEditorIfDeleted(node);

                                tree.delete_node(node);
                            }
                        };
                    } else {
                        // Действия для папок
                        menuItems.Create = {
                            separator_before: false,
                            separator_after: false,
                            label: "Создать",
                            action: false,
                            submenu: {
                                CreateFile: {
                                    label: "Файл",
                                    action: function () {
                                        // Запрашиваем имя файла у пользователя
                                        const newFileName = prompt("Введите имя нового файла:", "Новый файл.js");
                                        if (!newFileName) {
                                            // Пользователь отменил создание файла
                                            return;
                                        }

                                        // Проверка уникальности имени
                                        if (!checkUniqueName(node, newFileName, 'file')) {
                                            showMessage("Файл с таким именем уже существует в этой папке.");
                                            return;
                                        }

                                        const newId = 'file_' + Date.now();

                                        tree.create_node(node, {
                                            id: newId,
                                            text: newFileName,
                                            type: "file",
                                            data: { content: "" },
                                            state: { opened: true }
                                        }, "last", function(new_node) {
                                            setTimeout(function() {
                                                // Не открываем окно редактирования
                                                tree.select_node(new_node); // Автоматически выбрать новый файл (опционально)
                                            }, 0);
                                        });
                                    }
                                },
                                CreateFolder: {
                                    label: "Папка",
                                    action: function () {
                                        // Запрашиваем имя папки у пользователя
                                        const newFolderName = prompt("Введите имя новой папки:", "Новая папка");
                                        if (!newFolderName) {
                                            // Пользователь отменил создание папки
                                            return;
                                        }

                                        // Проверка уникальности имени
                                        if (!checkUniqueName(node, newFolderName, 'folder')) {
                                            showMessage("Папка с таким именем уже существует в этой папке.");
                                            return;
                                        }

                                        const newId = 'folder_' + Date.now();

                                        tree.create_node(node, {
                                            id: newId,
                                            text: newFolderName,
                                            type: "folder",
                                            state: { opened: true }
                                        }, "last", function(new_node) {
                                            setTimeout(function() {
                                                // Не открываем окно редактирования
                                                tree.select_node(new_node); // Автоматически выбрать новую папку (опционально)
                                            }, 0);
                                        });
                                    }
                                }
                            }
                        };

                        // Добавляем "Переименовать" и "Удалить" только если узел не корневой
                        if (node.id !== "root") {
                            menuItems.Rename = {
                                separator_before: false,
                                separator_after: false,
                                label: "Переименовать",
                                action: function () {
                                    tree.edit(node);
                                }
                            };
                            menuItems.Remove = {
                                separator_before: false,
                                separator_after: false,
                                label: "Удалить",
                                action: function () {
                                    if (node.id === "root") {
                                        return;
                                    }
                                    const parent = node.parent;
                                    const parentNode = tree.get_node(parent);
                                    const position = parentNode.children.indexOf(node.id) !== -1 ? parentNode.children.indexOf(node.id) : 'last';

                                    if (!isUndoing) {
                                        const fullNodeData = {
                                            id: node.id,             // Добавлено: id узла
                                            text: node.text,         // Добавлено: text узла
                                            type: node.type,
                                            data: node.type === 'file' ? { content: node.data.content || "" } : undefined,
                                            state: node.state,
                                            files: node.type === 'folder' ? gatherFiles(node) : undefined
                                        };
                                        undoStack.push({
                                            action: 'create',
                                            node: fullNodeData,
                                            parent: parent,
                                            position: position
                                        });
                                        console.log("Action Recorded to Undo Stack:", { action: 'create', node: fullNodeData, parent: parent, position: position });
                                    }

                                    // Очистка редактора, если удаляется текущий файл или файл внутри удаляемой папки
                                    clearEditorIfDeleted(node);

                                    tree.delete_node(node);
                                }
                            };
                        }
                    }

                    return menuItems;
                }
            },
            // Обработчики событий jsTree
        })
        .on('create_node.jstree', function (e, data) {
            if (data.node.type === 'file' && !isUndoing) {
                data.node.data = { "content": "" };
            }

            if (!isUndoing) {
                undoStack.push({
                    action: 'delete',
                    node: data.node.id
                });
                console.log("Action Recorded to Undo Stack:", { action: 'delete', node: data.node.id });
            }
        })
        .on('rename_node.jstree', function (e, data) {
            handleRename(data);
        })
        .on('delete_node.jstree', function (e, data) {
            // Обработка очистки редактора при удалении узла
            clearEditorIfDeleted(data.node);
        })
        // Обработчик события перемещения узла
        .on('move_node.jstree', function (e, data) {
            if (!isUndoing) {
                undoStack.push({
                    action: 'move',
                    node: data.node.id,
                    old_parent: data.old_parent,
                    old_position: data.old_position
                });
                console.log("Action Recorded to Undo Stack:", { action: 'move', node: data.node.id, old_parent: data.old_parent, old_position: data.old_position });
            }
        })
        // Добавление обработчика завершения операции drag-and-drop
        .on('dnd_stop.vakata', function (e, data) {
            if (duplicateNameError) {
                showMessage("В целевой папке уже существует узел с таким именем.");
                duplicateNameError = false; // Сбросить флаг после отображения сообщения
            }
        })
        .on('select_node.jstree', function (e, data) {
            saveCurrentFile();
            if (data.node.type === 'file') {
                loadFile(data.node);
            }
            // При выборе папки ничего не делаем с редактором
        });

        // Добавление обработчика для Ctrl+Z (или Cmd+Z на Mac)
        $(document).on('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                console.log("Ctrl+Z нажато");
                undo();
            }
            // Убираем обработку Ctrl+Y, если необходимо
        });

        // Добавление обработчика для кнопки "Сохранить проект"
        $('#save-button').on('click', function() {
            saveProject();
        });

        // Инициализация Monaco Editor
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            editor = monaco.editor.create(document.getElementById('editor'), {
                value: '',
                language: 'plaintext',
                theme: 'vs-dark',
                automaticLayout: true
            });

            // Обработка изменений в редакторе
            editor.onDidChangeModelContent(function() {
                if (isUndoing) {
                    // Игнорируем изменения, вызванные программным обновлением модели
                    return;
                }
                if (currentFile) {
                    currentFile.data.content = editor.getValue();
                    console.log(`Содержимое файла "${currentFile.text}" обновлено.`);
                    // Дополнительно: можно добавить авто-сохранение или уведомления
                }
            });
        });

    }); // Закрываем jQuery document ready
</script>
</body>
</html>
